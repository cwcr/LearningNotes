# RabbitMQ介绍

## RabbitMQ优异性

RabbitMQ发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ的具体特点可以概括为以下几点。

>* 可靠性：RabbitMQ使用一些机制来保证可靠性，如持久化、传输确认及发布确认等。
>* 灵活的路由：在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ已经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。
>* 扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。
>* 高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。
>* 多种协议：RabbitMQ除了原生支持AMQP协议，还支持STOMP、MQTT等多种消息中间件协议。
>* 多语言客户端：RabbitMQ几乎支持所有常用语言，比如Java、Python、Ruby、PHP、C#、JavaScript等。
>* 管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。
>* 插件机制：RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。

## RabbitMQ常见名词解释

**Broker:** 服务节点。如下图，Broker实际上是一个消息的中转站，负责接收、存储和转发消息

![RabbitMQ-Broker](.image/workflow-rabbitmq.png)

**Queue:** 队列。RabbitMQ的内部对象，用于存储消息。RabbitMQ的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。*但是当多个消费者订阅了同一个队列后，此时队列中的消息会被分摊(轮询)给多个消费者进行处理，而非每个消费者都会收到所有的消息。所以当有广播消费的需求时，建议在交换器层级进行处理，生产多个队列，而不是在队列层级做广播处理。*

**Exchange:** 交换器。生产者将消息发送到Exchange（交换器，通常也可以用大写的“X”来表示），由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。交换器由生产者声明，并设置相关属性(如交换机类型，是否持久化等)。

**RoutingKey:** 路由键。生产者将消息发给交换器的时候，消息一般会携带一个RoutingKey，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键(BindingKey)固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。

**BindingKey:** 绑定键。当BindingKey和RoutingKey相匹配时，消息会被路由到对应的队列中。BindingKey并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视BindingKey，而是将消息路由到所有绑定到该交换器的队列中。

**Binding:** 绑定。RabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键（BindingKey），这样RabbitMQ就知道如何正确地将消息路由到队列了。

**Connection:** 连接。无论是消息的生产者还是消费者，都需要和RabbitMQ Broker建立起连接来，这个连接就是一条TCP连接。

**Channel:** 信道。信道可以看作是连接的子集，是一个建立在Connection上的虚拟连接。客户端在建立起Connection后可以创建一个AMQP信道，每个信道都会被指派一个唯一的ID，每条AMQP指令都是通过信道完成处理的。信道主要是用来解决TCP连接创建和销毁太过耗费资源的问题，当出现请求高峰的时候，使用信道实现对TCP连接的复用可以有效降低性能瓶颈的到来。

## RabbitMQ交换器类型

RabbitMQ交换器有以下几种:

* fanout: 此类型交换器会将所有发送到该交换器的消息路由到与该交换器绑定的队列中。主要用于广播消息。
* direct：此类型交换器会将消息路由到BindingKey与RoutingKey完全匹配的队列中。主要用于指定匹配。
* topic: 此类型的交换器可以看作是在direct的基础上做的再次扩展，由于严格的完全匹配在很多情况下不能完全满足实际业务的需求，topic交换器支持做一定的模糊匹配，将消息按照模糊匹配的规则发送到对应的队列中。主要用于消息多发。
  * RoutingKey应为一个点号“.”分隔的字符串（被点号“.”分隔开的每一段独立的字符串称为一个单词），如“com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”
  * BindingKey和RoutingKey一样也是点号“.”分隔的字符串，但是BindingKey可以存在两种特殊字符"\*" 和 “#”做模糊匹配，其中 "\*"可以匹配一个字词,"#"可以用户匹配任意(含0)个单词。
* headers: 此类型交换器不依赖于RoutingKey和BindingKey的匹配规则来路由消息，而是依据发送消息内容中的headers属性进行匹配。该header属性是一组键值对，且在队列和消息中同时存在，只有在队列和消息中的header属性(键值对)完全匹配的时候，该消息会被路由到该队列中。性能较差，不常见，不常用。
* 自定义

## RabbitMQ消息交换方法

### 生产者生产消息

* 生产者连接到RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。
* 生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等。
* 生产者声明一个队列并设置相关属性，比如是否排他、是否持久化、是否自动删除等。
* 生产者通过路由键将交换器和队列绑定起来。
* 生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。
* 相应的交换器根据接收到的路由键查找相匹配的队列。
* 如果找到，则将从生产者发送过来的消息存入相应的队列中。
* 如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者。
* 关闭信道。
* 关闭连接。

### 消费者消费消息

* 消费者连接到RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。
* 消费者向RabbitMQ Broker请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作。
* 等待RabbitMQ Broker回应并投递相应队列中的消息，消费者接收消息。
* 消费者确认（ack）接收到的消息。
* RabbitMQ从队列中删除相应已经被确认的消息。
* 关闭信道。
* 关闭连接。