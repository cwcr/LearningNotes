# 微服务中的事务一致性保证

**CAP理论：** CAP 是指在一个分布式系统下，包含三个要素：Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），并且三者不可得兼。

一致性（Consistency），是指对于每一次读操作，要么都能够读到最新写入的数据，要么错误，所有数据变动都是同步的。

可用性（Availability），是指对于每一次请求，都能够得到一个及时的、非错的响应，但是不保证请求的结果是基于最新写入的数据。即在可以接受的时间范围内正确地响应用户请求。

分区容错性（Partition tolerance），是指由于节点之间的网络问题，即使一些消息丢包或者延迟，整个系统仍能够提供满足一致性和可用性的服务。

根据Eric Brewer提出的CAP理论，只能在数据强一致性（C）和可用性（A）之间做平衡。

关系型数据库单节点及单机事务可以保证了数据强一致性（C）和可用性（A），但是却无法安全的保证分区容错性（P）。

然而在分布式系统下，第一目标是为了保证模块的分区容错性（P），那么就需要在数据强一致性（C）和可用性（A）之间做平衡。具体表现为在一定时间内，不同模块之间相同数据可能是不一致的，这个时候就需要通过自动或手动补偿后，实现达到最终的一致的效果。

可用性一般是更好的选择，但是在服务和数据库之间维护事务一致性是非常根本的需求，微服务架构中应该选择满足最终一致性。

----

## 事务的实现

按照以上理论，**单机事务**在条件允许的情况下依然是最佳选择，分区容错性可以使用乐观锁来补偿。

但是当出现跨库的情况，则需要引进发布式事务。可以参考以下方案。

* [基于消息实现的分布式事务](#message)
* [基于补偿实现的分布式事务](#compensation)
* [基于TCC实现的分布式事务](#TCC)
* [基于SAGA实现的分布式事务](#saga)
* [基于2PC实现的分布式事务](#PC)

<span id="message"></span>

### 基于消息实现的分布式事务

基于消息实现的事务适用于分布式事务的提交或回滚只取决于事务发起方的业务需求，其他数据源的数据变更跟随发起方进行的业务场景。流程如下：

>* 发起方发起事务，完成操作，提交事务
>* 发起方发送消息至调用方
>* 调用方发起事务，完成操作，提交事务

可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程。因此基于消息队列实现的事务是我们除了单机事务外最优先考虑使用的形态。

但是此类事务无法满足调用方与发起方的事务一致性，调用方出现问题后，发起方无法得到补偿，最终出现双方数据不一致的问题。

<span id="compensation"></span>

### 基于补偿实现的分布式事务

基于补偿实现的分布式事务，可以解决消息分布式事务，两个事务不一致的问题，整个事务是否提交并不能只由单服务决定。流程如下：

>* 发起方发起事务，完成操作,事务挂起
>* 发起方发送消息至调用方
>* 调用方发起事务，完成操作，事务提交
>* 调用方事务提交成功后，回传消息至发起方
>* 发起方收到消息，提交事务

可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息来实现一致性事务，那么可以优先考虑使用基于补偿的事务形态。

<span id="TCC"></span>

### 基于TCC实现的分布式事务

由于补偿实现的分布式事务，是强同步的效果，无法满足两个服务之间的异步调用需求，TCC通过在补偿的基础上引入冻结(资源预留)的概念，来实现异步事务的效果

>* 发起方发起事务，完成部分操作,事务挂起
>* 发起方发送消息至调用方
>* 调用方冻结数据(可以含多种实现效果，比如冻结特定字段，使用Token+乐观锁冻结整条数据，整表冻结等)
>* 发起方无需关心调用方的执行情况，继续操作至结束，事务提交
>* 发起方再次发送消息至调用方
>* 调用方解冻数据，执行操作

TCC实际上是最为复杂的一种情况，其能处理几乎所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。

<span id="Sage"></span>

### 基于Saga实现的分布式事务

Saga是一个完全异步的、利用队列实现的补偿事务。不同于TCC,Saga不使用资源冻结，而是使用消息查询的方式来实现分布式事务。

>* 发起方发起事务，完成部分操作,事务提交
>* 发起方发送消息至调用方
>* 调用方处理数据
>* 调用方通知发起方(或一段时间后，发起方主动发起查询)
>* 发起方接受消息，完成剩余操作，事务提交

TCC相对于补偿事务形态有性能上的优势，所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。

因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。

<span id="PC"></span>

### 基于2PC(3PC)实现的分布式事务

参考[2PC事务介绍](https://www.hollischuang.com/archives/681)

2PC(3PC)引入了协调者的概念，发起者与调用者互相不可见，通过协调者来进行消息发送，然后发起者和调用者自己决定在正常流程/异常流程的处理情况。

2PC一致性事务相当灵活，伴随而来的是繁重的开发工作，且通信的开销明显增多，因此带来了网络通信阻塞，协调者单点故障以及数据在事务处理过程中发生变化带来的一致性问题。3PC的扩展仅降低了网络通信阻塞带来的风险并提供了补偿方案，但是其他问题依然是显而易见的。

如有充分的理由使用2PC事务，可以考虑使用[Paxos算法](https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95)。

----

## 不同类型事务使用

不同业务场景应按需引入不同的事务形态，在条件允许的情况下，建议按照如下次序选择对应的事务形态：

> 单机事务》基于消息的事务》基于补偿的事务》TCC事务

Saga事务需要配合较为明显的前端业务交互变更，建议在单一事务执行过程较长、存在较多子事务，并且无法使用基于消息的事务形态时使用。
